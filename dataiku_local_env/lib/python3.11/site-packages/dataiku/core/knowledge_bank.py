# encoding: utf-8

from dataiku.base.folder_context import build_readonly_knowledge_bank_folder_context
from dataiku.core import intercom, default_project_key
from dataiku.core.vector_stores.dku_vector_store import VectorStoreFactory
import os


class KnowledgeBank(object):

    """
    This is a handle to interact with a Dataiku Knowledge Bank flow object
    """
    def __init__(self, id, project_key=None):
        self.id = id
        if "." not in id:
            try:
                self.project_key = project_key or default_project_key()
                self.short_name = id
                self.name = self.project_key + "." + id
            except:
                raise Exception("Knowledge bank %s is specified with a relative name, "
                                "but no default project was found. Please use complete name" % self.id)
        else:
            # use gave a full name
            (self.project_key, self.short_name) = self.id.split(".", 1)
            if project_key is not None and self.project_key != project_key:
                raise ValueError("Project key %s incompatible with fullname Knowledge bank %s." % (project_key, id))
        self.full_name ="%s.%s" % (self.project_key, self.short_name)
        self.location_info = None
        self.cols = None
        self.rk = None

    def _get(self):
        if self.rk is None:
            self.rk = intercom.backend_json_call("knowledge-bank/get", data={
                    "knowledgeBankFullId": self.full_name
            })
        return self.rk

    def as_langchain_retriever(self, search_type="similarity", search_kwargs=None, vectorstore_kwargs=None, **retriever_kwargs):
        """
        Get this Knowledge bank as a Langchain Retriever object
        """
        search_kwargs = search_kwargs or {}
        vectorstore_kwargs = vectorstore_kwargs or {}

        return self.as_langchain_vectorstore(**vectorstore_kwargs).as_retriever(search_type=search_type,
                                                            search_kwargs=search_kwargs,
                                                            **retriever_kwargs)

    def as_langchain_vectorstore(self, **vectorstore_kwargs):
        """
        Get this Knowledge bank as a Langchain Vectorstore object
        """
        self.rk = self._get()
        from dataiku.langchain.dku_embeddings import DKUEmbeddings
        embeddings = DKUEmbeddings(llm_id=self.rk["embeddingLLMId"])

        vectorstore_path = None
        if VectorStoreFactory.needs_local_path(self.rk):
            vectorstore_path_in_backend = intercom.backend_json_call("knowledge-bank/get-vectorstore-local-path", data={
                "knowledgeBankFullId": self.full_name
            })["path"]
            folder_context = build_readonly_knowledge_bank_folder_context(vectorstore_path_in_backend, self.full_name)
            # Prevent downloading the same KB version more than once.
            if not os.path.exists(folder_context.get_absolute_folder_path()):
                with folder_context.get_folder_path_to_read() as local_path:
                    vectorstore_path = local_path
            else:
                vectorstore_path = folder_context.get_absolute_folder_path()

        vector_store = VectorStoreFactory.get_vector_store(self.rk, vectorstore_path)

        return vector_store.get_db(embeddings, **vectorstore_kwargs)

    def get_multipart_context(self, docs):
        """
        Convert retrieved documents from the vector store to a multipart context.
        The multipart context contains the parts that can be added to a completion query

        :param docs: A list of retrieved documents from the langchain retriever
        :type docs: List[Document]
        :returns A multipart context object composed by a list of parts containing text or images
        :rtype MultipartContext
        :raises Exception: If the knowledge bank does not contain multimodal content
        """
        from dataiku.langchain.metadata_handler import MetadataHandler, RetrievalSource

        self.rk = self._get()

        multimodal_column = self.rk.get("multimodalColumn")
        if not multimodal_column:
            raise Exception("Knowledge bank {id} does not contain multimodal content".format(id=self.id))

        multipart_context = MultipartContext()
        for index, document in enumerate(docs):
            parts = MetadataHandler.get_multipart_content(document, RetrievalSource.MULTIMODAL, full_folder_id=self.rk.get("managedFolderId"), index=index)
            for part in parts:
                multipart_context.append(part)
        return multipart_context


class MultipartContext:

    def __init__(self):
        self.parts = []

    def append(self, part):
        self.parts.append(part)

    def add_to_completion_query(self, completion, role="user"):
        """
        Creates a completion multipart message and adds all the parts of the context to it
        """
        multipart_message = completion.new_multipart_message(role=role)
        for part in self.parts:
            if part.type == "TEXT":
                multipart_message.with_text(part.text)
            elif part.type == "IMAGE_INLINE":
                multipart_message.with_inline_image(part.inline_image, mime_type=part.image_mime_type)
        multipart_message.add()

    def is_text_only(self):
        for part in self.parts:
            if part.type != "TEXT":
                return False
        return True

    def to_text(self):
        text_content = ""
        for part in self.parts:
            if part.type == "TEXT":
                text_content += part.text
                text_content += "\n\n"
        return text_content
