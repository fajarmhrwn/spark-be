from typing import TYPE_CHECKING, Union, Dict, Tuple

from elasticsearch import UnsupportedProductError
from elasticsearch.helpers.vectorstore import DenseVectorStrategy
from langchain_elasticsearch import ElasticsearchStore

from dataiku.core.vector_stores.dku_vector_store import DkuRemoteVectorStore, logger

if TYPE_CHECKING:
    from dataikuapi.dss.admin import DSSConnection
    from elasticsearch.helpers.vectorstore import RetrievalStrategy


class ElasticSearchVectorStore(DkuRemoteVectorStore):

    elasticsearch_url: str
    auth_kwargs: Dict or None
    version: Tuple[int, int] or None

    def __init__(self, kb: Dict, exec_folder: str):
        super(ElasticSearchVectorStore, self).__init__(kb, exec_folder)

    def set_index_name(self, index_name: str):
        self.index_name = index_name.lower()

    def init_connection(self, connection: "DSSConnection") -> None:
        connection_params = connection.get_info()['params']
        auth_type = connection_params['authType']
        self.auth_kwargs = {}
        scheme = "http"
        if connection_params['ssl']:
            scheme = "https"
            if connection_params['trustAnySSLCertificate']:
                self.auth_kwargs['es_params'] = {'verify_certs': False}

        self.elasticsearch_url = "{}://{}:{}".format(scheme, connection_params['host'], connection_params['port'])
        if auth_type == "NONE":
            pass
        elif auth_type == "PASSWORD":
            self.auth_kwargs['es_user'] = connection_params['username']
            self.auth_kwargs['es_password'] = connection_params['password']
        elif auth_type == "OAUTH2_APP":
            raise NotImplementedError("OAuth v2.0 is not supported for Knowledge Banks")
        elif auth_type in ["AWS_KEYPAIR", "AWS_ENVIRONMENT", "AWS_STS", "AWS_CUSTOM"]:
            # This error will be caught by the VectorStoreFactory and trigger the use of OpenSearch implementation instead
            raise UnsupportedProductError("'{}' authentication is only supported with OpenSearch".format(auth_type), {},{"version": {"distribution": "opensearch"}})
        else:
            raise ValueError("Unknown authentication type: " + auth_type)

        self.version = self.get_version()

    def get_rrf_settings(self, rag_settings: Dict) -> Union[Dict, bool]:
        advanced_reranking = rag_settings.get("useAdvancedReranking", False)
        if advanced_reranking:
            k = self._get_search_kwargs(rag_settings)["k"]
            return {
                "rank_constant": rag_settings.get("rrfRankConstant", 60),
                "rank_window_size": rag_settings.get("rrfRankWindowSize", k)
            }
        return False

    def _get_db_kwargs(self, rag_settings: Dict) -> Dict:
        hybrid = rag_settings.get("useHybridSearch", False)
        rrf_settings = self.get_rrf_settings(rag_settings)
        if self.version < (8, 16) and rrf_settings:
            raise ValueError("RRF is only supported with ElasticSearch v8.16+")
        strategy = self.get_strategy(hybrid, rrf_settings)
        return {"strategy": strategy}

    def get_db(self, embeddings, allow_creation=False, **kwargs) -> "ElasticsearchStore":
        """
        Instantiate the ElasticsearchStore db object

        :param embeddings: embeddings used to create the vector store
        :param allow_creation:  unused
        :param kwargs: if the `strategy` is provided, it will be used to instantiate the db object instead of the default one
        :rtype: ElasticsearchStore
        """
        # todo should check if index already exist to raise an error if allow_creation=false first (langchain always create it by default if unfound)

        # Enforce correct strategy instantiation if none present in kwargs
        kwargs["strategy"] = kwargs.get("strategy", self.get_strategy())

        db = ElasticsearchStore(
            es_url=self.elasticsearch_url,
            index_name=self.index_name,
            embedding=embeddings,
            **{**self.auth_kwargs, **kwargs}
        )
        return db

    def get_strategy(self, hybrid=False, rrf: Union[Dict, bool] = False) -> "RetrievalStrategy":
        # ES versions < v8.4 does not support the KNN query (default strategy used in `ElasticsearchStore`),
        # so we need to use a less efficient strategy based on custom script scoring
        if self.version < (8, 4):
            logger.info("Using DenseVectorScriptScoreStrategy instead of KNN query params.")
            from elasticsearch.helpers.vectorstore import DenseVectorScriptScoreStrategy
            return DenseVectorScriptScoreStrategy()
        else:
            return DenseVectorStrategy(hybrid=hybrid, rrf=rrf)

    def get_version(self) -> [int, int]:
        # We retrieve the db first so that we get a chance to raise an UnsupportedProductError
        # that will be caught by the VectorStoreFactory if we are connecting to an OpenSearch
        db = ElasticsearchStore(index_name=self.index_name, es_url=self.elasticsearch_url, **self.auth_kwargs)
        try:
            version_number = db.client.info()["version"]["number"]
            logger.info("Connected to ElasticSearch v{}".format(version_number))
            v = version_number.split(".")
            return int(v[0]), int(v[1])
        # Reraise the exception as a ConnectionError
        except Exception as e:
            raise ConnectionError("Could not retrieve ElasticSearch version: {}".format(e))

    def clear_index(self):
        self.get_db(None).client.indices.delete(
            index=self.index_name,
            ignore_unavailable=True,
            allow_no_indices=True
        )
        logger.info("Cleared ElasticSearch index {}".format(self.index_name))
