import json
import os
import shutil
import portalocker

from dataiku.core.vector_stores.dku_vector_store import DkuLocalVectorStore, logger
from qdrant_client import QdrantClient
from qdrant_client.http.models import VectorParams, Distance
from qdrant_client.http import models as rest_models
from qdrant_client.local.local_collection import LocalCollection

from qdrant_client.local.qdrant_local import QdrantLocal, META_INFO_FILENAME

try:
    from langchain_qdrant import QdrantVectorStore as LangchainQdrant
except ImportError:
    from langchain_community.vectorstores import Qdrant as LangchainQdrant


# Monkeypatch of _load() method in QdrantLocal
# Uses read-only permission when opening the lock file instead of r+ (read and write)
# Enables readers to use the KB in UIF setups
# The lock file should be created only by dss unimpersonated code or any user with the write permission
def load_qdrant_monkey_patch(local_client) -> None:
    if not local_client.persistent:
        return
    meta_path = os.path.join(local_client.location, META_INFO_FILENAME)
    if not os.path.exists(meta_path):
        os.makedirs(local_client.location, exist_ok=True)
        with open(meta_path, "w") as f:
            f.write(json.dumps({"collections": {}, "aliases": {}}))
    else:
        with open(meta_path, "r") as f:
            meta = json.load(f)
            for collection_name, config_json in meta["collections"].items():
                config = rest_models.CreateCollection(**config_json)
                collection_path = local_client._collection_path(collection_name)
                local_client.collections[collection_name] = LocalCollection(
                    config,
                    collection_path,
                    force_disable_check_same_thread=local_client.force_disable_check_same_thread,
                )
            local_client.aliases = meta["aliases"]

    lock_file_path = os.path.join(local_client.location, ".lock")
    if not os.path.exists(lock_file_path):
        os.makedirs(local_client.location, exist_ok=True)
        with open(lock_file_path, "w") as f:
            f.write("tmp lock file")
    local_client._flock_file = open(lock_file_path, "r")  # Important: keep it read only
    try:
        portalocker.lock(
            local_client._flock_file,
            portalocker.LockFlags.EXCLUSIVE | portalocker.LockFlags.NON_BLOCKING,
            )
    except portalocker.exceptions.LockException:
        raise RuntimeError(
            f"Storage folder {local_client.location} is already accessed by another instance of Qdrant client."
            f" If you require concurrent access, use Qdrant server instead."
        )


QdrantLocal._load = load_qdrant_monkey_patch


class QDrantLocalVectorStore(DkuLocalVectorStore):

    def __init__(self, kb, exec_folder):
        super(QDrantLocalVectorStore, self).__init__(kb, exec_folder, collection_name="knowledge_bank")

    def get_db(self, embeddings, allow_creation=False, **kwargs):

        client = QdrantClient(path=self.exec_folder)
        if not client.collection_exists(self.collection_name):  # todo should check for allow_creation first
            embedding_size = self.get_vector_size()
            client.create_collection(
                collection_name=self.collection_name,
                vectors_config=VectorParams(size=embedding_size, distance=Distance.COSINE),
            )
        return LangchainQdrant(client, self.collection_name, embeddings)

    def clear_files(self, folder_path):
        if os.path.isfile(os.path.join(folder_path, "meta.json")):
            os.remove(os.path.join(folder_path, "meta.json"))

        if os.path.isdir(os.path.join(folder_path, "collection")):
            shutil.rmtree(os.path.join(folder_path, "collection"))

        if os.path.isfile(os.path.join(folder_path, ".lock")):
            os.remove(os.path.join(folder_path, ".lock"))

        logger.info("Cleared QDrant vector store files at {}".format(folder_path))

