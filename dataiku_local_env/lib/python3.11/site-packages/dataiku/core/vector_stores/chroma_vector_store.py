import os
import re
import shutil
import logging
import json
from typing import TYPE_CHECKING, Dict, List
from dataiku.core.vector_stores.dku_vector_store import DkuLocalVectorStore, logger
from dataiku.langchain.metadata_handler import DKU_MULTIMODAL_CONTENT


METADATA_SAMPLE_LENGTH = 25


class ChromaVectorStore(DkuLocalVectorStore):

    def __init__(self, kb, exec_folder):
        super(ChromaVectorStore, self).__init__(kb, exec_folder, collection_name="langchain")
        self.run_the_ugly_chromadb_monkeypatch()
        self.metadata_columns_schema = kb.get("metadataColumnsSchema", [])

    def get_db(self, embeddings, allow_creation=False, **kwargs):
        # import locally to let the monkeypatch run before
        try:
            from langchain_chroma import Chroma as LangchainChroma
        except ImportError:
            from langchain_community.vectorstores import Chroma as LangchainChroma
        import chromadb
        client_settings = chromadb.config.Settings(
            anonymized_telemetry=False,
            persist_directory=self.exec_folder,
            is_persistent=True,
        )
        db = LangchainChroma(collection_name=self.collection_name, embedding_function=embeddings, client_settings=client_settings)
        db._client.get_or_create_collection(name=self.collection_name)  # todo should check for allow_creation first
        return db

    def clear_files(self, folder_path):
        if os.path.isfile(os.path.join(folder_path, "chroma.sqlite3")):
            os.remove(os.path.join(folder_path, "chroma.sqlite3"))

        for file in os.listdir(folder_path):
            # if filename matches regex, remove it
            if re.match(r"[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}", file):
                shutil.rmtree(os.path.join(folder_path, file))

    def transform_document_before_load(self, document):
        SECURITY_TOKENS_META="DKU_SECURITY_TOKENS"

        if SECURITY_TOKENS_META in document.metadata:
            security_tokens = json.loads(document.metadata[SECURITY_TOKENS_META])

            for token in security_tokens:
                document.metadata["DKU_SECURITY_TOKEN_%s" % token] = "true"

            logging.info("Updated metadata to %s" % ChromaVectorStore.sanitize_for_print(document.metadata))

        return document

    @staticmethod
    def sanitize_for_print(metadata: Dict):
        """
        :return: a copy of the metadata dict with shrinked multimodal content if required, the original dict otherwise
        :rtype: Dict
        """
        # Might be best to also shrink other fields of the dict ?

        if DKU_MULTIMODAL_CONTENT in metadata and len(metadata[DKU_MULTIMODAL_CONTENT]) > METADATA_SAMPLE_LENGTH:
            sanitized_meta = dict(metadata)  # make a copy not to modify the original document
            # DKU_MULTIMODAL_CONTENT can contains very long str, shrink it to a few chars to avoid flooding
            sanitized_meta[DKU_MULTIMODAL_CONTENT] = sanitized_meta[DKU_MULTIMODAL_CONTENT][0: METADATA_SAMPLE_LENGTH] + "..."
            return sanitized_meta
        return metadata

    def add_security_filter(self, search_kwargs: Dict, caller_security_tokens: List):

        #logging.info("search_kwargs are %s" % search_kwargs)
        #logging.info("caller_security_tokens are %s" % caller_security_tokens)

        security_clauses = []
        for caller_security_token in caller_security_tokens:
            security_clause = {
                "DKU_SECURITY_TOKEN_%s" % caller_security_token : {
                    "$eq": "true"
                }
            }
            security_clauses.append(security_clause)

        if len(security_clauses) == 0:
            raise Exception("No caller security tokens provided for vector store security filter")

        elif len(security_clauses) > 1:
            security_clauses_top = {"$or" : security_clauses}
        elif len(security_clauses) == 1:
            security_clauses_top = security_clauses[0]

        if not "filter" in search_kwargs:
            search_kwargs["filter"] = security_clauses_top
        else:
            search_kwargs["filter"] = {
                "$and" : [
                    search_kwargs["filter"],
                    security_clauses_top
                ]
            }

        logging.info("search_kwargs updated to %s" % search_kwargs)

    def add_filter(self, search_kwargs: Dict, filter: Dict):
        metadata_column_type = {col["name"]: col["type"] for col in self.metadata_columns_schema}

        def coerce_value(clause):
            clause_type = metadata_column_type.get(clause["column"], None)  # DSS storage type
            if clause_type in ["bigint", "int", "smallint", "tinyint"]:
                return int(clause["value"])
            elif clause_type in ["double", "float"]:
                return float(clause["value"])
            else:
                return clause["value"]

        def translate_clause(clause):
            if clause["operator"] == "EQUALS":
                return { clause["column"] : {"$eq": coerce_value(clause)} }
            elif clause["operator"] == "NOT_EQUALS":
                return { clause["column"] : {"$ne": coerce_value(clause)} }
            elif clause["operator"] == "GREATER_THAN":
                return { clause["column"] : {"$gt": coerce_value(clause)} }
            elif clause["operator"] == "LESS_THAN":
                return { clause["column"] : {"$lt": coerce_value(clause)} }
            elif clause["operator"] == "GREATER_OR_EQUAL":
                return { clause["column"] : {"$gte": coerce_value(clause)} }
            elif clause["operator"] == "LESS_OR_EQUAL":
                return { clause["column"] : {"$lte": coerce_value(clause)} }
            elif clause["operator"] == "AND":
                return { "$and" : [translate_clause(x) for x in clause["clauses"]] }
            elif clause["operator"] == "OR":
                return { "$or" : [translate_clause(x) for x in clause["clauses"]] }
            else:
                raise Exception("Unsupported filter operator for Chroma: %s" % clause["operator"])

        filter_clause_top = translate_clause(filter)

        if not "filter" in search_kwargs:
            search_kwargs["filter"] = filter_clause_top
        else:
            search_kwargs["filter"] = {
                "$and" : [
                    search_kwargs["filter"],
                    filter_clause_top
                ]
            }

    @staticmethod
    def run_the_ugly_chromadb_monkeypatch():
        logger.info("maybe-monkeypatching Chroma")
        import importlib

        chromadb_spec = importlib.util.find_spec("chromadb")

        if chromadb_spec is None:
            logger.info("Chroma is not installed, ignoring monkeypatch")
            return

        import sqlite3

        if sqlite3.sqlite_version_info < (3, 35, 0):
            logger.warning("SQLite3 is too old, Chroma would not load, trying to replace sqlite3. " +
                            "Please consider upgrading to sqlite3 >= 3.35")
            try:
                __import__('pysqlite3')
            except ModuleNotFoundError:
                logger.exception("Failed to import pysqlite3 to replace sqlite3")
                raise ModuleNotFoundError("Could not import Chroma directly due to SQLite version issue, and pysqlite3-binary is not installed, cannot work-around. Consider installing pysqlite3-binary package")

            try:
                import sys
                sys.modules['sqlite3'] = sys.modules.pop('pysqlite3')
            except:
                logger.exception("Failed to replace sqlite3 by pysqlite3")
                raise ModuleNotFoundError("Could not import Chroma directly due to SQLite version issue, and applying work-around failed")

            try:
                # Check that it's working now
                logger.info("monkeypatched, retrying")
                import chromadb
            except Exception as e:
                logger.exception("chromadb monkeypatch did not work")
                raise ModuleNotFoundError("Could not import Chroma directly due to SQLite version issue, and applying work-around failed") from e
